The following is my very first attempt at writing a full malware report; the executable I will be analyzing is a PE file named `main_bin.exe` with SHA256 
```
a0ac02a1e6c908b90173e86c3e321f2bab082ed45236503a21eb7d984de10611
``` 
It is a custom sample provided as exercise as part of the amazing malware analysis course [Zero2Automated](https://courses.zero2auto.com/) (Z2A to friends), which I am slowly &ndash; *very* slowly &ndash; but steadily working on.

I will try to go as in-depth as my current level of knowledge allows while also trying to not bore the dear readers to death with the (perhaps excessive?) level of detail those who know me are probably dreading already. I don't know if I will succeed in this but I sure will try; please, do not be shy to share any feedback (positive and negative alike) on either the content or the style with me; I am doing this to learn! This having been said, let's go on to take a look at our cute little piece of malware...

**NOTE**: The first stage of this sample uses a very simple string encryption algorithm which I honestly took way too long to identify (epic fail alert!)... Nevertheless, I decided to share my whole thought process as I think it still has some value and also because it will allow me to showcase a very nice tool I discovered; hopefully this will give some meaning to the time that would otherwise go completely wasted!

## A First Glance at the Sample

My first step in this adventure will be taking a look at the executable at a very high level, with the initial objective of identifying whether it may be packed or not. In order to do this, I load it in [pestudio](https://www.winitor.com/download), where the main things I notice are the following:
+ The only resource present, having numeric identifier 101 (0x65 in hex) and of type `RT_RCDATA` is **huge** (~87 kB, more than half the size of the whole executable itself) and likely encrypted given the high entropy value; it wouldn't surprise me at all to discover it is the actual malicious payload waiting to be unleashed. Scrolling through the "strings" tab also shows a large number of what look like obfuscation/encryption artifacts, which further confirms this hypothesis.
  
  <p align="center">
    <img src="img/resource.png">
  </p>
+ The only library with explicit references seems to be `kernel32.dll`, but when checking the imports `LoadLibraryA`, `LoadLibraryExW` and `GetProcAddress` immediately jump to the eye as they strongly suggest that additional API loading will occur dynamically at runtime.
+ Among the imports it is also possible to notice a couple APIs which are red flags for potential anti-analysis checks, such as `IsDebuggerPresent` as well as `QueryPerformanceCounter`, which can be (ab)used to determine e.g. whether someone is single-stepping through the code. 
+ If we exclude the `.rsrc` section, the sections of this binary look pretty "standard"; there are no big discrepancies between raw and virtual sizes, entropy values are not suspiciously high and there are no weird sections such as `.text1` or similar.

  <p align="center">
    <img src="img/sections.png">
  </p>

Overall (perhaps because of my lack of experience), I have to admit that at this point it is not trivial for me to claim whether our sample can be technically defined to be "packed" or not; as stated above, I have a strong suspicion that it is hiding an encrypted payload in its resources, but is this enough to say that it is "packed" considering that I am not sure what this "second-stage" payload is going to be used for? Furthermore, the way sections are organized does not suggest the presence of some unpacking stub meant to be overwritten with the unpacked code... Because of this, I decided I will treat the binary as unpacked and I will therefore skip the default unpacking routine.  

## Static Analysis Galore

I want to figure out more about this sample's functionalities (that's why we are here, isn't it), but I don't feel like I have enough understanding of it (yet) to go through dynamic analysis; furthermore, I would like to see if I can manage to confirm whether the resource is indeed encrypted and - if yes - how; maybe it could be a good opportunity to put on my Python programmer hat and write a nice decryptor!

Personally, I have been a fan of [Ghidra](https://ghidra-sre.org/) for years, so this is the tool I will use; I am not going to lose any chance to pull some IDA folks to the dark side...

Either way, once I load the sample into our favorite SRE suite, I decide to start by focusing on the `LoadLibrary` and `GetProcAddress` imports I had previously observed. `LoadLibraryExW` quickly loses my interest as I see that it is only referenced by two very similar-looking functions (one located at address 0x402b8e and the other at 0x407a6c, with image base being set at 0x400000) which, it seems, were automatically identified by the so-called FunctionID feature of Ghidra as `try_get_first_available_module` from the Visual Studio 2019 Release. Checking out `LoadLibraryA`, though, yields way more interesting results.
<p align="center">
    <img src="img/LoadLibraryA_xrefs.png">
</p>

It looks like it is invoked multiple times within 2 different functions, one located at 0x401000 and the other at 0x401400, labeled &ndash; in very pragmatic fashion, although at the expense of creativity &ndash; `FUN_00401000` and `FUN_00401400` respectively by Ghidra. Let us take a look at how Ghidra decompiles the former to see which libraries and APIs are being loaded.
<p align="center">
    <img src="img/fun_00401000_dec_LoadLibraryA.png">
</p>

Well, by looking at the format of the strings being passed to `LoadLibraryA` and `GetProcAddress` I would say that we are likely dealing with encrypted or otherwise obfuscated strings. Nevertheless, I notice the call following the very first invocation to `GetProcAddress`; 10 arguments, the 6th of which has the constant value 4... Could it be a call to something such as `CreateProcess`, with the value 4 representing the flag `CREATE_SUSPENDED`? It is certainly plausible if we assume the sample is going to try and perform some type of process injection; if this hypothesis is correct, the first parameter &ndash; identified by Ghidra as the variable `local_408` &ndash; is the name of the process to be created. Let's see where this variable gets a value assigned to it. 
<p align="center">
    <img src="img/fun_00401000_dec_local_408.png">
</p>

A call to `GetModuleFileNameA`! This means that our `local_408` is indeed meant to contain a string representing the path of some executable, and since the first parameter has value 0 the executable in question will be the current process &ndash; i.e. the sample itself. 

Given the above, I can now start formulating some kind of hypothesis: the sample is likely going, at some point, to load and decrypt the mysterious resource (which I am now even more convinced must be a second-stage executable) and then somehow pass it to this `FUN_00401000` which will take care to inject it into another instance of the sample itself. Since I am expecting the resource to be manipulated via functions such as `FindResource`, `FindResourceEx`, `LoadResource` and so on, I am going to try and scan the memory to see whether at any point the constant 0x65 (101 in decimal, the numeric identifier of the single available resource as we saw before) is pushed to the stack as a function parameter.
<p align="center">
    <img src="img/memory_search_0x65.png">
</p>

Sure enough, there is a hit for the hex sequence `6a 65` (0x6a being the opcode for the `PUSH` instruction in this context)! Interestingly, it is located within `FUN_00401400`, which is the other function we found containing references to `LoadLibraryA` (and `GetProcAddress`). Let's take a look at the decompiled function.
<p align="center">
    <img src="img/fun_00401400_dec_FindResourceA.png">
</p>

Well, the call `(*pFVar3)(0,0x65,10)` is extremely likely to be a call to `FindResource`, with the second parameter being the resource identifier and the third one &ndash; the constant 10 &ndash; likely representing the flag `RT_RCDATA`, which is indeed the type assigned to our resource. One of the two following calls then has to be the invocation to `LoadResource`, although at this point I am not yet confident about which one.

Before trying to actually look deeper at the string decryption/deobfuscation algorithm used by the sample, which I believe has to be located within the function labeled as `FUN_00401300` since all strings passed to `LoadLibraryA` and `GetProcAddress` are processed by it beforehand, I wished to understand a bit more about the overall control flow of the process; fortunately, in this case it was exceedingly simple, as the flow seems to be quite linear: it looks like the only function calling `FUN_00401000` is `FUN_00401400` itself, which is in turn invoked exclusively from the executable's entry point. Given that `FUN_00401400` appears to be the only "meaty" function, so to speak, invoked directly from the entry point and &ndash; most importantly &ndash; due to the fact that the value it returns is what is in turn returned to the system by the process, I am going to assume that it is the sample's `main` function and will be referring to it as such. 
<p align="center">
    <img src="img/entry_dec_main.png">
</p>

By the way, note to myself: Ghidra's Function Call Trees are a really nice utility! 
<p align="center">
    <img src="img/function_call_trees.png">
</p>

## The String Encryption Routine

Now let's see if we can understand the algorithm used by the sample to decrypt the strings passed to `LoadLibraryA` and `GetProcAddress`. As mentioned above, such algorithm is very likely contained within the function `FUN_00401300`, which I will therefore rename as `string_decrypt` for simplicity.

Unfortunately, it turns out reversing the algorithm by just looking at the decompiled code may not be too easy. After preparing what looks like some sort of stack canary and measuring the length of the input string, the main decryption loop starts; within this loop, the string `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890./=` is created on the stack and then passed to another function, `FUN_00402190`, together with a single character from the input string.
<p align="center">
    <img src="img/string_decrypt_first_part.png">
</p>

At this point, it seems that Ghidra's decompiling capabilities lose some steam and it becomes more convenient to look at the raw disassembly to get an idea of what may be happening; overall, it looks like `FUN_00402190` returns the address of a character inside the stack string (likely derived from the value of the character from the input string), which is then used to calculate a corresponding offset to the beginning of the string. 
<p align="center">
    <img src="img/string_decrypt_second_part.png">
</p>

After that, a ROT13-like operation along the stack string is performed starting from the identified offset in order to determine the byte which corresponds to the decrypted character. The input string is finally edited in place. 
<p align="center">
    <img src="img/string_decrypt_third_part.png">
</p>

**NOTE**: If `FUN_00402190` returns `NULL`, the byte to be stored in the input string will be the least significant byte of the address returned by a `malloc` invocation; I am not sure why, but either way this seems to be an error case which is not supposed to occur if a valid input is provided, therefore I will not delve into this further unless it becomes necessary. 

We are almost there! In order to be able to write a decryptor, we still need to understand how `FUN_00402190` (which I will rename to `decryption_step_1`) computes its output... But here is where the problem really lies; this function is **messy**! 
<p align="center">
    <img src="img/decryption_step_1_dec.png">
</p>

Yeah... No, I am not going to look into that. Gotta find an alternative, which is likely going to involve dynamic analysis. And here I am pleased to introduce a very cool emulation framework I just learnt about, [Qiling](https://github.com/qilingframework/qiling). As long as it is properly set up, it can be used to emulate processes for several different platforms, and it is extremely easy to start using, although there is probably a whole lot more I will have to learn about it.

In this case, my idea is to play around with Qiling to emulate `decryption_step_1` and basically try and see if I can do some "black-box" analysis of the algorithm, i.e. reversing it by looking just at inputs and outputs.

The portion of code I am interested in emulating is the one that starts with the creation of the stack string...
<p align="center">
    <img src="img/emulation_begin.png">
</p>

...And ends immediately after the call to `decryption_step_1`:
<p align="center">
    <img src="img/emulation_end.png">
</p>

So, my start address will be 0x401340 and the end address will be 0x401397. But I am not done yet; I need to ensure that the function will receive the correct parameters! The first one shouldn't be a problem, since it is the address of the stack string itself and we are going to include its creation as part of the emulated code; the second one though, which should represent a character from the string to be decrypted, is determined with the instruction `MOV BL, byte ptr [ECX + ESI * 0x1]`, where `ECX` points to the encrypted string and `ESI` acts as a counter. The problem is that the portion of emulated code does not define `ECX` nor `ESI`! This means that we will have to set appropriate values manually before starting the emulation. In order to do this, I identify one of the encrypted strings used by the sample and look up its address; in this case I arbitrarily picked the string `pe51g5Ceb35ffn`, used within `FUN_00401000` and located at address 0x4148a4.
<p align="center">
    <img src="img/encrypted_string.png">
</p>

Now it's time to spin up the Python interpreter and perform the emulation. 

```
>>> from qiling import *
>>> q = Qiling(["main_bin.exe"], '.') # select executable and rootfs
[...]
>>> q.arch.regs.write('ECX', 0x4148a4) # Ensure ECX points to the encrypted string
>>> q.arch.regs.write('ESI', 0) # Set ESI to 0 to point to first char of encrypted string, "p"
>>> q.run(begin=0x401340, end=0x401397) # Emulate the portion of code between the two addresses
[...]
>>> hex(q.arch.regs.read('EAX')) # See the output of the function
'0xffffcfc7'
>>> q.mem.read(0xffffcfc7, 1) # See the character pointed to by the returned address
bytearray(b'p')
```

Wait a second, the output of `decrypt_step_1` for input `p` is... `p`? Let's try again...

```
i>>> q = Qiling(["main_bin.exe"], '.') # Let's reload the sample 
[...]
>>> q.arch.regs.write('ECX', 0x4148a4) # Ensure ECX points to the encrypted string
>>> q.arch.regs.write('ESI', 1) # Set ESI to 1 to point to second char of encrypted string, "e"
>>> q.run(begin=0x401340, end=0x401397)
[...]
>>> hex(q.arch.regs.read('EAX')) # See the output of the function
'0xffffcfbc'
>>> q.mem.read(0xffffcfbc, 1) # See the character pointed to by the returned address
bytearray(b'e')
```

I get it now... For all the weirdness of its decompiled code, `decrypt_step_1` is simply identifying the location of the character to be decrypted on the stack string! Which means that the whole algorithm  used by `decrypt_string` is just ROT13, although it uses more characters than just the Latin alphabet... I guess my whole analysis was kind of an overkill.

In hindsight, I should have probably assumed that I was dealing with an "extended charset" version of ROT13 as soon as I saw the peculiar stack string and the constant value 0xd (13 in decimal) being employed in the computations; then, I could have easily validated my hypothesis by testing it on one of the encrypted strings without having to go through the whole code analysis... Oh well, lesson learnt! I guess the only thing that remains for me to do is writing a simple Python function to do the "decryption" and test whether I got it right.

<details>
<summary> string_decrypt.py </summary>

```python
import sys
  
def rot13(string):
        buffer = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890./="
        buffer_len = len(buffer)

        output = []

        for c in string:
                output.append(buffer[(buffer.find(c) + 13) % buffer_len])

        return "".join(output)

def main():
        string = sys.argv[1] # The string to be decrypted

        print(rot13(string))

if __name__ == "__main__":
        main()
```

</details>

Now I can test it on the same string I had previously chosen, `pe51g5Ceb35ffn`.
<p align="center">
    <img src="img/CreateProcessA_dec.png">
</p>

Awesome, it works! Now I can use it to decrypt all the other strings used by the sample, which will make it easier to move forward.

## Full Overview of `main` and `FUN_00401000`

After decrypting all strings and doing some refactoring in Ghidra to make the code more readable, understanding what the "core" functions of the sample do becomes a whole lot easier. Let's start by looking at our `main`.
<p align="center">
    <img src="img/main_after_decryption.png">
</p>

It seems that my original assumptions were correct; the resource is loaded in memory and then a pointer to its data (which I named `res_ptr`) is retrieved by invoking `LockResource`. Then we see memory being allocated via `VirtualAlloc` and data from the resource being copied to the freshly allocated memory; I believe the data copied to this new memory region is soon going to be decrypted, hence I refer to the region itself as `decrypted_res`. 

The most interesting piece of information here is that it looks like the first 28 bytes of the resource are not actually copied (the second parameter of `_memcpy` is `res_ptr + 0x1c`); furthermore, the dword at offset 8 is apparently multiplied by 10 to obtain a value which is then passed as size parameter to both `VirtualAlloc` and `_memcpy`. We can take a look at the first bytes of the resource e.g. from within the [PE-bear](https://hshrzd.wordpress.com/pe-bear/) utility.
<p align="center">
    <img src="img/pe_bear_resource.png">
</p>

At offset 8 we find the dword 0x2200, 8704 in decimal, which multiplied by 10 gives 87040; 87040 + 28 = 87068, which as pestudio had previously shown is the size of the resource! It looks like the first 28 bytes are used as some sort of "header", while the remaining data is likely the actual encrypted content. At this point it is unclear what the other values in this "header" represent, but if they are significant we will definitely see them used somewhere. 

Although the `main` function continues, I believe the second half of it deserves to be discussed separately, hence for the time being I will focus instead on `FUN_00401000`.

In practice though there is not a whole lot to say about this function; as we had initially suggested, it expects to receive a PE file as input (further confirmed by the fact that it looks for a pointer to the PE header at offset 0x3c and then uses it to check for the presence of the PE signature )...
<p align="center">
    <img src="img/pe_check.png">
</p>

...Then uses `CreateProcessA` to spawn a new instance of the sample in a suspended state... 
<p align="center">
    <img src="img/CreateProcessA.png">
</p>

...And proceeds to perform PE injection against it so that it actually executes the second-stage payload. To be fair, initially I had assumed that the technique being used was process hollowing, mostly because the set of WinAPI functions being invoked is almost the same; later though I realized that the memory of the original process is never unmapped, which is why I don't think it would make sense to talk about process "hollowing". Although the procedure being used to perform the injection is nothing special, on this occasion I will be quickly walking through the most important code portions; first, the function gets the thread context of the newly created process...
<p align="center"> 
    <img src="img/GetThreadContext.png">
</p>

...Then, it allocates memory in the new process equal to the size of the image to be injected (`pe_header_ptr[0x14]` points to the `SizeOfImage` value in the PE header, see [this map](https://en.wikipedia.org/wiki/Portable_Executable#/media/File:Portable_Executable_32_bit_Structure_in_SVG_fixed.svg) for reference) and copies the payload's headers to it (the amount of bytes to be written in `WriteProcessMemory` is defined by `pe_header_ptr[0x15]`, pointing to `SizeOfHeaders`); note that the desired address where the memory should be allocated is indicated by `pe_header_ptr[0xd]`, which points to the `ImageBase` entry.
<p align="center"> 
    <img src="img/copy_payload_to_proc_mem.png">
</p>

Once this has been done, it looks like the executable is actually mapped into the memory of the new process; indeed, we see the function performing a series of calls to `WriteProcessMemory`, looping over the sections defined in the payload (`pe_header_ptr + 6` points to the `NumberOfSections` entry in the PE header). 
<p align="center"> 
    <img src="img/memory_map.png">
</p>

Almost there! Now the thread context of the suspended process is updated. First, the `ImageBaseAddress` value at offset 0x8 of the PEB (Process Environment Block) of the process &ndash; which is stored in the `EBX` register upon process creation &ndash; is made to point to the image base address for our payload rather than the original process...
<p align="center"> 
    <img src="img/modify_thread_context_ebx.png">
</p>

...Then the execution entry point &ndash; stored in the `EAX` register &ndash; is also appropriately updated to point to the entry point of the injection payload (`pe_header_ptr[10]` points to `AddressOfEntryPoint` in the PE header).
<p align="center"> 
    <img src="img/modify_thread_context_eax.png">
</p>

Finally, the new thread context is set by invoking `SetThreadContext` and the main thread is resumed in order to execute the payload's code!
<p align="center"> 
    <img src="img/resume_thread.png">
</p>

## Decrypting the Injection Payload

We are almost done with the analysis of the first stage! As I noted earlier, there is still a portion of code in the `main` function that I temporarily skipped but is perhaps the most important.
<p align="center">
    <img src="img/RC4_algo_dec.png">
</p>

It looks like after the (likely encrypted) data from the resource is copied into the newly allocated region of memory (see the previous section for the analysis of the first part of the function), it is processed by an algorithm which has all the trappings of RC4 before being passed to `FUN_00401000` (which I renamed to `inject_pe`) for injection. What suggests the idea of RC4 to me are the first two `do...while` loops performing 256 (0x100 in hex) iterations each followed by the third loop which includes a XOR operation involving the supposed ciphertext (stored in the not-too-aptly-named variable `decrypted_res`). 

Indeed, at a closer look the first two loop seem indeed to correspond exactly to the so-called Key Scheduling Algorithm (KSA) in RC4, whereas in the third loop we can see the Pseudo-Random Generation Algorithm being at work to generate the bytes to be XORed with the ciphertext. Looking at the second loop in particular, we see the following line:
```
bVar3 = bVar3 + *(char *)(j % 0xf + 0xc + res_ptr) + bVar1
```
Although it is perhaps not immediately obvious, here the byte pointed to by the expression `j % 0xf + 0xc + res_ptr` corresponds to a byte from the temporary buffer `T` used in the KSA to generate the initial permutation of the state vector `S`; in turn, `T` is directly derived from the encryption key by repetition, which suggests to us that the key we need has to be lenght 15 (0xf in hex) and has to be located at offset 0xc within the resource's 28-byte "header"! Now we can just go back and check those bytes again in PE-bear...
<p align="center">
    <img src="img/pe_bear_key.png">
</p>

Ok, last step: I want to write a Python script that, given the executable and the resource ID, automatically decrypts and dumps the payload to disk.
<details>
<summary> second_stage_decrypt.py </summary>

```python
import sys
import pefile
from Crypto.Cipher import ARC4

def get_resource(pe, resource_id):

        for rsrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                for entry in rsrc.directory.entries:
                        if entry.id == resource_id:
                                offset = entry.directory.entries[0].data.struct.OffsetToData
                                size = entry.directory.entries[0].data.struct.Size

        return pe.get_memory_mapped_image()[offset:offset+size]


def dump_payload(resource, out_file):

        key = resource[12:27]
        payload = resource[28:]

        cipher = ARC4.new(key)
        decrypted_payload = cipher.decrypt(payload)

        with open(out_file, "wb") as output:
                output.write(decrypted_payload)


def main():

        pe = pefile.PE(sys.argv[1]) # The PE file being analyzed
        resource_id = int(sys.argv[2]) # ID of the target resource
        out_file = sys.argv[3] # Name of the output file

        resource = get_resource(pe, resource_id)

        dump_payload(resource, out_file)


if __name__ == "__main__":
        main()
```
</details>  


Once we run the above script as `python second_stage_decrypt.py main_bin.exe 101 second_stage.bin`, we will see that `second_stage.bin` is indeed a valid PE file with SHA256 
```
a4997fbff9bf2ebfee03b9373655a45d4ec3b1bcee6a05784fe4e022e471e8e7
```
Looks like it's time to move to stage 2!

## Hashing APIs for Fun and Profit

First things first, I immediately feed the new executable to pestudio; again, I see no evidence of packing, and this time there are no interesting resources either &ndash; to be precise, there are no resources at all. 

Interestingly, though, this binary &ndash; like the first stage &ndash; seems to explicitly import only `kernel32.dll` and contains references to both `LoadLibraryA` and `GetProcAddress`, hence I am led once more to believe dynamic loading has to be going on. I also notice again references to functions such as `IsDebuggerPresent` and `QueryPerformanceCounter`, but as I recall that in the first stage they didn't seem to be invoked by any of the key functions we analyzed, I am going to assume for the time being that they are likely used within some library functions for purposes unrelated to malicious anti-debug techniques. If at some point we will need to perform dynamic analysis I will double-check this assumption.

For now, I will focus again on static analysis and I will adopt a similar approach to stage 1; i.e., I will start by looking at the functions where `LoadLibraryA` and `GetProcAddress` are invoked. 
<p align="center">
    <img src="img/stage2_LoadLibraryA.png">
</p>

Ok, looks like the only function referring to `LoadLibraryA` is `FUN_00401210`, so I will focus on that one first. I immediately notice that it takes two parameters, the first of which is seemingly used as an index for a vector of strings.
<p align="center">
    <img src="img/param1_index.png">
</p>

Checking out the supposed vector, I see that it contains 3 pointers to strings representing Windows DLLs.
<p align="center">
    <img src="img/string_vector.png">
</p>

So, the first parameter of the function is clearly selecting a DLL to be loaded: 0 means `kernel32.dll`, 1 is for `ntdll.dll` and 2 corresponds to `wininet.dll`. Looking on at the rest of the function, I notice that most of its body is taken by a `while(true)` loop which terminates when a variable is equal to the second parameter; after that, `GetProcAddress` is finally invoked and the resulting address is returned by the function. This behavior smells like API hashing, which I further confirm when I check the parameters passed to `FUN_00401210` by one of the functions invoking it, `FUN_00401dc0`.
<p align="center">
    <img src="img/api_hash_params.png">
</p>

Now, I can be quite lazy when I put my heart into it, and this is one of those times where I really feel like being lazy; indeed, I'd rather not go through the effort of reversing the hashing routine and then reimplementing it. Fortunately, looking the first constant `0xda16a83d` up on Google helped me immensely by returning [this document](https://github.com/tildedennis/malware/blob/master/phasebot/api_hashes) on GitHub; it looks like the hashing algorithm being used is a known one and someone has already mapped the hashes to the corresponding APIs! Indeed, thanks to this document I am going to be able to identify all the API functions being loaded by the process via calls to `FUN_00401210` (which I renamed to `load_api`). For example, after mapping the hashes above I identify some APIs being loaded from `wininet.dll`.
<p align="center">
    <img src="img/wininet_apis.png">
</p>

Looking inside the function `FUN_00401660`, which is seemingly the one invoked by `load_api` to compute API hashes, I am also able to identify the hashing routine as CRC32 thanks to several references to the constant `0xedb88320`, which is, according to Google, a "reversed" representation of the CRC32 generator polinomial.

Now that we know how to deobfuscate the APIs being invoked, analyzing the rest of the executable should be much easier... 

**NOTE**: Since there is quite a bit of code that still needs to be reversed, from now on I will not be able to be as detailed as I have tried to be until now when explaining my thought process; I will instead focus on describing the functionalities I identified, going more in-depth only when it feels necessary.

## Enter CruLoader!

First of all, I walk the function call tree backwards from `load_api` until I identify `FUN_00401ea0` as the likely `main` function for the executable (using the same kind of reasoning I used when analyzing the first stage). This function proceeds to check the filename of the current process by computing its CRC32 hash and comparing it with the value `0xb925c42d`. As I did for the Windows API functions, I looked this constant up on Google and I found [this article](https://docs.broadcom.com/doc/trojan-bamital-13-en), where this value is associated with the filename `svchost.exe`. To be **absolutely** transparent, I also encountered quite a few blogs from people who had solved the same challenge before me &ndash; but I did not look at those, I swear!

Now, if the second stage payload is running in the context of `svchost.exe` then the function `FUN_00401dc0` which I previously mentioned is invoked. After loading the `wininet.dll` APIs I showed above, this function proceeds to decrypt a 33-byte long string stored at `0x413c7c` which corresponds to the url `https://pastebin.com/raw/mLem9DGk`. Although the "decryption" algorithm being used is trivial... 
<p align="center">
    <img src="img/stage2_string_decryption.png">
</p>

...Since I noticed the same algorithm being used to decrypt other strings I wrote another small Python script to automate the process.
<details>
<summary> stage2_string_decrypt.py </summary>

```python
import sys
import pefile

def decrypt(string, key):

	output = []

	for b in string:
		output.append(chr(((b << 4 | b >> 4) % 256) ^ key))

	return "".join(output)


def main():

	filename = sys.argv[1] # The PE file being analyzed
	start_addr = int(sys.argv[2], 16) # RVA of the string, in hex
	len = int(sys.argv[3]) # Length of the string
	xor_key = int(sys.argv[4], 16) # Hex value of the byte used in the XOR operation

	pe = pefile.PE(filename)

	string = pe.get_data(start_addr, len)

	print(decrypt(string, xor_key))


if __name__ == "__main__":
	main()
```

</details>

The script is invoked in this case as `python stage2_string_decrypt.py 0x13c7c 33 0xc5` and yields the URL string mentioned above. This string is then passed on to another function &ndash; which I accordingly named `retrieve_page` &ndash; which downloads the corresponding content and returns a pointer to it; the pointer is finally passed to yet another function, which Ghidra refers to as `FUN_004013a0`. 

Before analyzing this new function, it is interesting to note the string `cruloader` being passed as first parameter to `InternetOpenA`. 
<p align="center">
    <img src="img/cruloader.png">
</p>

This is apparently how our sample wants to call itself, since this parameter will be the user agent for its HTTP requests. Well, at least now we also have a name to call it with!

Going back to `FUN_004013a0`, first of all it invokes `retrieve_page` a second time, passing to it... The content we had just retrieved from Pastebin? While this may initially make little sense, it becomes clear when we check the Pastebin URL ourselves.
<p align="center">
    <img src="img/pastebin_content.png">
</p>

Another URL! This one, `https://i.ibb.co/KsfqHym/PNG-02-Copy.png`, allegedly points to a PNG image, so this is what the function is now going to download. After downloading the image, it is then written to a file on disk under path `<temp>\cruloader\output.jpg`, where `<temp>` is the path returned by a `GetTempPathW` invocation. Note that the portion `\output.jpg` is actually decrypted from a string stored at address `0x413ca4` and can be obtained by invoking the script I made with the command line `python stage2_string_decrypt.py second_stage.bin 0x13ca4 11 0x1f`.

After the file is written to disk, we have an interesting portion of code, which I think is worth going over more carefully. First, yet another string, `redaolurc` ("cruloader" reversed), is decrypted from bytes stored at address `0x413cc4`; we can do it once again with the script, using the command line `python stage2_string_decrypt.py 0x13cc4 9 0x9a`. After that we have another portion of code looking for the sequence of bytes corresponding to this same string within the PNG file itself; when it is found, the amount of bytes following the string in the PNG file is stored in a global variable (which I called `remaining_length` cause I couldn't find a better name).
<p align="center">
    <img src="img/find_redaolurc.png">
</p>

Following that, we have some "esoteric" decompilation by Ghidra...
<p align="center">
    <img src="img/png_decrypt.png">
</p>

...Which in much, much (much) simpler terms corresponds to XORing each byte following the string "redaolurc" in the PNG with the value 0x61. This is actually a **third-stage** payload that will be injected into a newly created instance of `C:\Windows\System32\svchost.exe` (this time via process hollowing for real)! Note that, once again, the path of the executable to be launched is stored in an "encrypted" string at address `0x413c5c` which can still be decrypted with my script by running `python stage2_string_decrypt.py second_stage.bin 0x13c5c 31 0xa2`.

So, to summarize, if our second-stage detects that it is somehow already running in the context of `svchost.exe` it will spawn yet another instance of `svchost.exe` and inject the third-stage payload into it by performing process hollowing. What if it is running inside the context of a `main_bin.exe` process (which is what happens when the sample is executed for the first time)? Well, simple enough: an instance of `svchost.exe` is spawned and the second-stage performs PE injection of itself into `svchost.exe`, using `CreateRemoteThread` to execute `FUN_00401dc0`, which is the very first function we analyzed in this section; talk about "going full circle"!

**NOTE**: To add some more information about how the PE injection is executed in practice here, it looks like the sample:
+ Allocates memory equal to the size of its own image in its own address space 
+ Copies its own memory-mapped image to the allocated region
+ Allocates memory equal to the size of its own image in the address space of `svchost.exe` 
+ Computes relocations for the image to be injected assuming the base address of the region allocated in `svchost.exe` as the base of the relocated image
+ Copies the relocated image to the allocated memory in `svchost.exe`
+ Invokes `CreateRemoteThread` as mentioned above

As we did for the second-stage payload earlier, now I will again come up with a Python script to retrieve the third-stage payload assuming the PNG image has already been downloaded onto the analysis machine. 
<details>
<summary> third_stage_decrypt.py </summary>

```python
import sys

def dump_payload(png, output):

	out_buff = bytearray()

	with open(png, 'rb') as png_file:
		png_buff = png_file.read()

	payload_start = png_buff.find(b'redaolurc') + 9

	payload = png_buff[payload_start:]

	for i in range(len(payload)):
		out_buff.append(payload[i] ^ 0x61)

	with open(output, 'wb') as output_file:
		output_file.write(out_buff)


def main():

	png = sys.argv[1] # The PNG file containing the payload
	output = sys.argv[2] # Name of the output file

	dump_payload(png, output)


if __name__ == "__main__":
	main()
```

</details>

After running this script with command line `python third_stage_decrypt.py PNG-02-Copy.png third_stage.bin` (assuming `PNG-02-Copy.png` is the name of the downloaded PNG file), `third_stage.bin` will be, as expected, a valid PE file with SHA256 
```
a84b6fa193bd8d17065907744354333f0d0240a0498a4c6fdef75e3ac9620606
```
Well, what are we waiting for? Let's finish this!

## Anti-Analysis in the Second-Stage Payload

Before moving forward with the (extremely short, to be honest) analysis of the third and final payload in this exercise, I first have to make a quick note on the presence of anti-analysis techniques within the second-stage payload itself for the sake of completeness. 

Although my initial assumption concerning the imports for `IsDebuggerPresent` and `QueryPerformanceCounter` shown by pestudio turned out to be correct (i.e. they are only used by some unrelated library functions), anti-analysis is indeed being employed; namely, if the second stage is running within the context of `main_bin.exe`, before proceeding further with the PE injection against `svchost.exe` it will perform two invocations.
<p align="center">
    <img src="img/anti_debug_functions.png">
</p>

For what concerns the dynamically-loaded `IsDebuggerPresent`, this one is quite self-explanatory. More interesting is the other function being called, `FUN_00401000`. What is immediately noticeable about this function is that is seems to scan the processes running on the system using the APIs `CreateToolhelp32Snapshot`, `Process32FirstW` and `Process32NextW`; we can also easily notice the same constant `0xedb88320` which, as we already established, is a dead giveaway that the CRC32 hashing algorithm is in use. What is basically happening here is that the names of the executables backing each process running on the system are hashed and compared to each of 4 hardcoded hashes stored in a vector on the stack.
<p align="center">
    <img src="img/process_name_hashes.png">
</p>

If there is a match, then the function will return 1; if there are no matches, the function returns 0. If the value being returned is 1, there will be no PE injection at all. 

This behavior seems to correspond to CruLoader looking either for processes which may reveal it is running within a VM (say e.g. `vmtoolsd.exe` for VMware guests) or for processes commonly used by malware analysts (such as `x32dbg.exe` or any other well-known debugger), or perhaps both; if such a process is found, CruLoader will &ndash; understandably &ndash; assume that it is under someone's microscope and avoid disclosing its functionality. 

Now, unfortunately, when I tried to look the hardcoded hashes up on Google, this time I only got a single result, which ironically was the report of another fellow Z2A student. As a matter of principle I have no intention to look at that, which means that in order to achieve the 100% completionist badge I should attempt to bruteforce the hashes myself... In order to do that I should build a list of process names that this function may look out for, compute the hashes and compare them with the hardcoded values hoping to find some matches. Honestly, I don't think it is the case to go through that pain (did I already say I can be quite lazy?); for this time I will content myself with having an idea of what the function is likely supposed to do and knowing that, if I had to debug the sample, bypassing this check should be as easy as manually setting the value returned by the function to 0. 95% completion cannot be *that* bad, can it?

## The Final Stage and Conclusions

Concerning the third-stage payload, there is very little to say; it is a very small file (less than 10 kB) and it is immediately clear why when one looks at its `main` function, which can be easily found among those invoked from the executable's entry point when using the rationale I described in an earlier section.
<p align="center">
    <img src="img/third_stage_main.png">
</p>

Yes, it's what it looks like: just an innocuous dialog box telling the poor victim that unlucky them, they have indeed been h4xx3d! Well, what were we expecting after all? It was just an exercise, not really meant to be malicious!

And just like that, we have come to the end of this report; if you have followed  me until here, congratulations for your mental resistance! Jokes aside though, I really hope this was an interesting read, if lengthy. Personally, I had a lot of fun working on this and I am more convinced than ever that malware forensics is where I want to be.

Before closing, I also wanted to recommend the Z2A course to anyone who is interested in learning more about malware reversing; it is really incredible value for the price! 

With that, thank you for reading and until the next malware sample &ndash; maybe a real one, this time!
